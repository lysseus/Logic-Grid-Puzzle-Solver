#lang racket

;;;
;;; TABLE
;;;

(provide build-table-images show-table current-answers)

(require (for-syntax syntax/parse)
         2htdp/image
         (only-in utils/2htdp/image images-max-dims)
         (only-in "../common.rkt" cat-text-images prop-text-images
                  FRAME-W-PAD FRAME-H-PAD FONT-SIZE FONT-COLOR
                  UNKNOWN TRUE FALSE TRUE-COLOR FALSE-COLOR
                  valid-key/c debug-printf)
         (only-in "../queries.rkt" ? ?= ?true))

(define current-answers (make-parameter empty))

(define-syntax table-images
  (λ (stx)
    (syntax-parse stx [table-images:id #'(current-table-images)])))
(define current-table-images (make-parameter #f))


;; Create a hash of images for the table.
(define (build-table-images inits)
  ;; Get the categories.
  (define cs (map car inits))    
  (define-values (cat-text-w cat-text-h) (images-max-dims cat-text-images))
  (define-values (prop-text-w prop-text-h) (images-max-dims prop-text-images))
  (define max-w (max cat-text-w prop-text-w))
  (define max-h (max cat-text-h prop-text-h))
  (define frame-w (+ max-w FRAME-W-PAD))
  (define frame-h (+ max-h FRAME-H-PAD))  
  (current-table-images
   (for/hash ([v (append (hash->list cat-text-images)
                         (hash->list prop-text-images)
                         (list (cons 'valid? (text (~a 'valid?) FONT-SIZE FONT-COLOR)))
                         (list (cons '? (text (~a UNKNOWN) FONT-SIZE FONT-COLOR)))
                         (list (cons #f (text (~a FALSE) FONT-SIZE FALSE-COLOR)))
                         (list (cons #t (text (~a TRUE) FONT-SIZE TRUE-COLOR))))])
     (values (car v)
             (overlay (cdr v)
                      (rectangle frame-w frame-h 'outline FONT-COLOR))))))

(define (draw-vld-box row cats ans)
  (define result (validate row cats ans))
  (hash-ref table-images result))

(define (make-table cs)
  (printf "cs=~a~%" cs)
  (define c (last cs))
  (printf "c=~a~%" c)
  (define prop-names (remove c cs))
  (printf "prop-names=~a~%" prop-names)
  (define props (for/list ([p (? c)])
                  (cons c p)))
  (printf "props=~a~%" props)
  (define rows (reverse (for/fold ([rows empty])
                                  ([prop props])
                          (define prop-val (cdr prop))
                          (cons (cons prop-val (for/list ([prop-name (remove c cs)])
                                                 (?true prop prop-name)))
                                rows))))
  (printf "rows=~a~%" rows)
  (define header (beside (apply beside
                                (map (λ (v) (hash-ref table-images v))
                                     (cons c prop-names)))
                         (hash-ref table-images 'valid?)))
  (define rows-img
    (apply above/align "left"
           empty-image
           (for/list ([row rows])
             (beside (apply beside
                            (map (λ (v) (hash-ref table-images (if (false? v) '? v)))
                                 row))
                     (draw-vld-box row cs (current-answers))))))

  #;(define ans-img (validate (current-answers)))
  #;(define footer
    (overlay/align "center" "bottom"
                   ans-img
                   (rectangle (image-width header)
                              (+ FRAME-H-PAD (image-height ans-img))
                              'outline FONT-COLOR)))
  
  (above/align "left"
               header
               rows-img
               #;footer))
#;(define (make-table cs)
  (printf "cs=~a~%" cs)
  (define c (last cs))
  (printf "c=~a~%" c)
  (define prop-names (remove c cs))
  (printf "prop-names=~a~%" prop-names)
  (define props (for/list ([p (? c)])
                  (cons c p)))
  (printf "props=~a~%" props)
  (define rows (reverse (for/fold ([rows empty])
                                  ([prop props])
                          (define prop-val (cdr prop))
                          (cons (cons prop-val (for/list ([prop-name (remove c cs)])
                                                 (?true prop prop-name)))
                                rows))))
  (printf "rows=~a~%" rows)
  (define header (apply beside
                        (map (λ (v) (hash-ref table-images v))
                             (cons c prop-names))))
  (define rows-img
    (apply above/align "left"
           empty-image
           (for/list ([row rows])
             (apply beside
                    (map (λ (v) (hash-ref table-images (if (false? v) '? v)))
                         row)))))

  (define ans-img (validate (current-answers)))
  (define footer
    (overlay/align "center" "bottom"
                   ans-img
                   (rectangle (image-width header)
                              (+ FRAME-H-PAD (image-height ans-img))
                              'outline FONT-COLOR)))
  
  (above/align "left"
               header
               rows-img
               footer))

(define (show-table)
  (make-table (? 'cs)))

#;(define (validate ans)
  (->* () #:rest (listof (listof valid-key/c)) any)
  (debug-printf "~a~%" ans)
  (define sol (for/and ([row ans])
                (debug-printf "row=~a~%" row)
                (define 1st (first row))
                (define rel
                  (remove-duplicates (apply append
                                            '() (map set->list (?= 1st)))))
                (debug-printf "rel=~a~%" rel)
                (define ans (remove* rel row))
                (debug-printf "ans=~a~%" ans)
                (if (empty? ans) #t #f)))
  (debug-printf "sol=~a~%" sol)
  (define txt (cond
                [(empty? ans) UNKNOWN]
                [(false? sol) FALSE]
                [else TRUE]))
  (text (~a txt)
        FONT-SIZE
        (case txt
          [(FALSE) FALSE-COLOR]
          [(TRUE) TRUE-COLOR]
          [else 'yellow])))

(define (member/car v lst)
  (define vs (list->vector (map car lst)))
  (define n (vector-member v vs))
  (if (false? n)
      #f
      (drop lst n)))

(define (validate row cats ans)
  (define (f key cat-order ans)
    (define vs
      (for/first ([ans ans]
                  #:when (member key ans))
        ans))
    (define (loop cat-order (acc empty))
      (cond
        [(empty? cat-order) (reverse acc)]
        [else
         (define cat (car cat-order))
         (define v (cdar (member/car cat vs)))
         (loop (cdr cat-order) (cons v acc))]))
  
    (loop cat-order))
  (cond [(empty? ans) '?]
        [(member #f row) '?]
        [else         
         (define order (cons (last cats) (take cats (sub1 (length cats)))))
         (equal? row (f (cons (car order) (car row)) order ans))]))

